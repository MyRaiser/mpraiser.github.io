# 计算机基础

[TOC]

## 硬件表达二进制数

### 符号约定

名称 | 符号 | 缩写含义
:-: | :-: | :-:
$X$ | 数$X$的值 | -
$[X]_u$ | 数$X$的无符号表达形式 | unsigned
$[X]_t$ | 数$X$的原码表达形式 | true form
$[X]_{1c}$ | 数$X$的反码表达形式 | one's complement
$[X]_{2c}$ | 数$X$的补码表达形式 | two's complement
$+_u$ | 无符号加法 | unsigned

### 无符号数

我们知道一个数字电路的输出具有两种状态：$0$或者$1$，称为一个`bit`。那么如果有$n$个`bit`，则可以表示的状态总数有$2^n$个。一个最简单的思路是直接将各比特的值当作二进制数各位上的数码，那么，一个比特序列$[X]_u = x_{n-1}\cdots x_1 x_0$对应的实际数值为

$$X = \sum_{i=0}^{n-1} x_i \cdot 2^i$$

表示范围是

$$
\begin{aligned}
X &: &0 &\sim 2^n - 1 \\
[X]_u &: &\underbrace{00 \cdots 0}_n &\sim \underbrace{11 \cdots 1}_n
\end{aligned}
$$

**无符号（unsigned）数**就是这么表示的，无符号数只能表示非负数，$n$位无符号数表示$[0, 2^n)$之间的数。

#### 无符号数加法器

我们首先实现无符号数的加法器。特别注意，由于只有$n$位，实际上实现的是

$$(a + b) \mod 2^n$$

因此我们说无符号数加法器实现的其实是模意义上的“$+$”。无符号数的表示集合与无符号数加法构成了一个阿贝尔群$\langle N_u, +_u\rangle$。

### 有符号数

对于实际应用中光零与正数是不够的，我们还需要考虑的问题有：

1. 如何表示负数？
2. 如何实现减法？

#### 原码

如果首先考虑表示负数的问题，要表达负数怎么办呢？

最naive的做法是对于$n$位有符号数，可以选取$1$个**符号位**用来充当正负号，剩余$n-1$位使用无符号数的方式表示数的绝对值。

表示范围是$(-2^{n-1}, 2^{n-1})$：

$$
\begin{aligned}
X &: &0 &\sim &2^{n-1} - 1 &, &-0 &\sim &-(2^{n-1} - 1) \\
[X]_t &: &0\_\underbrace{00 \cdots 0}_{n-1} &\sim &0\_\underbrace{11 \cdots 1}_{n-1} &,  &1\_\underbrace{00 \cdots 0}_{n-1} &\sim &1\_\underbrace{11 \cdots 1}_{n-1}
\end{aligned}
$$


这种对于正负数的编码方式称作**原码（true form）**。

#### 反码

现在该考虑怎么实现减法了。这个时候我们发现了大问题：原码的加减法实在是太复杂了。加法就很复杂了，还需要做一完全不一样的减法，能不能只用一套器件同时实现加减法？

我们知道，对于两个正数，减去一个数相当于加上其相反数（即加法逆元）：

$$a - b =  a + (-b)$$

对于逆元有：

$$x + (-x) = 0$$

但是在使用$+_u$的原码表示中，两个相反数之和不能满足

$$[X]_t +_u [-X]_t = [0]_t$$

比如4位下$[1]_t$与$[-1]_t$之和、$[2]_t$与$[-2]_t$之和为

$$
0001 + 1001 = 1002 \\
0010 + 1010 = 1020
$$

并且这个问题也没有办法通过简单的对符号位处理得到正确答案。不过通过观察可以发现把负数的表示中除了符号位以外的部分取个反就可以形式上解决这个问题：

$$
\begin{aligned}
X &: &0 &\sim &2^{n-1} - 1 &, &-(2^{n-1} - 1) &\sim &-0 \\
[X]_t &: &0\_\underbrace{00 \cdots 0}_{n-1} &\sim &0\_\underbrace{11 \cdots 1}_{n-1} &,  &1\_\underbrace{00 \cdots 0}_{n-1} &\sim &1\_\underbrace{11 \cdots 1}_{n-1}
\end{aligned}
$$

表示范围与原码相同，仍为$(-2^{n-1}, 2^{n-1})$；这种编码方式称为**反码（one's complement）**。

反码可以保证

$$
[X]_{1c} +_u [-X]_{1c} = \underbrace{11 \cdots 1}_n
$$

#### 补码

原码与反码依然具有一些显而易见缺点：

1. $0$被以$+0$和$-0$的方式重复表达了两遍
2. 反码虽然解决了逆元的问题，但是加法器本身还是很复杂，并且也不是$+_u$

现在让我们重新审视加法。对于$[0, 2^n)$上的模加法，其加法逆元满足

$$-X = 
\left\{\begin{aligned}
    0, X = 0 \\
    2^n -X, X > 0
\end{aligned}\right.$$

前文提过无符号数$\langle N_u, +_u\rangle$中的无符号加法$+_u$其实就是模加法，所以沿用$+_u$来做有符号的加法是可行的，但是要做一些调整。我们仍然选取$1$位做符号位，剩余$n-1$位作如下处理：

1. 如果是正数或者零，保持不变
2. 如果是负数，取$+_u$的逆元（这使得我们在有符号数中仍然能使用无符号的$+_u$！）

$$
\begin{aligned}
\text{dec}&: &0 &\sim &2^{n-1} - 1 &, &-2^{n-1} &\sim &-1 \\
\text{bin}&: &0\_\underbrace{00 \cdots 0}_{n-1} &\sim &0\_\underbrace{11 \cdots 1}_{n-1} &,  &1\_\underbrace{00 \cdots 0}_{n-1} &\sim &1\_\underbrace{11 \cdots 1}_{n-1}
\end{aligned}
$$

表示范围为$[-2^{n-1}, 2^{n-1})$。这种编码方式称为**补码（two's complement）**。

对于符号位：

1. 如果两数符号位一致，那么和的符号位保持相同。

2. 如果两数符号位不一致，那么和是大的操作数减去小的操作数，加和结果的符号位和较大的操作数符号位保持一致。

#### 再谈反码

反码在工程实践上可能出现的比补码更早。

对于反码，如果要求$[-X]_{1c}$，做法是：

1. 符号位不变
2. 其他位取反

考虑一个正数$X$, $[X]_{1c}$符号位以外的位为$n-1$位无符号数$[Y]_{1c}$，$[-X]_{1c}$对应的为$[-Y]_{1c}$，我们知道：

$$
[Y]_{1c} +_u [-Y]_{1c} = \underbrace{1 1 \cdots 1}_{n - 1}
$$

而$\underbrace{1 1 \cdots 1}_{n - 1}$实际上就是无符号数中的$2^{n-1} - 1$，因此有

$$
[Y]_{1c} + [-Y]_{1c} = 2^{n-1} - 1
$$

$$
[-Y]_{1c} = 2^{n-1} - 1 - [Y]_{1c}
$$


可以看到这个形式上与模加法的逆元$[-Y]_{2c} = 2^{n-1} - [Y]_{2c}$非常相像。

首先从计算形式上，**负数的补码非符号位可以通过反码$+1$得到**，有：

$$[-Y]_{2c} = [-Y]_{1c} + 1 = 2^{n-1} - [Y]$$

这提供了一个方便的得到$+_u$逆元的方法。

反码具有与原码一样的问题：$0$被重复编码为$+0$、$-0$

从补码的设计思想上回过来看，这不仅仅是浪费了一个码位的问题，而是破坏了代数结构，使得加法器的设计比较困难。



